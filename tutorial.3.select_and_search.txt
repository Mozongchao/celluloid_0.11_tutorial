0        1         2         3         4         5         6         7         8
12345678901234567890123456789012345678901234567890123456789012345678901234567890

###############################################################################
## if the user has saved the RdaDevDev files, they can be loaded:
## files<-system("ls RdaDev/*RdaDev", intern=T); for( f in files){load(f)}
###############################################################################

The present file describe ways to obtain solutions for the ploidy, cellularity 
and subclonal proportions.  Two objective functions (functions that need to be
minimized with respect to the parameters) are described, one that is segment
-based and one that is peak-based.  The pipeline.r file uses the former.

When a fully automatic search of solutions fails to provide a satisfying 
answer, perharps because of extended noise or subclones, celluloid offers the 
user the possibility of using manual interventions for greater control. These
are further described when presenting the peak-based objective function. 

###############################################################################

1) Segment-based objective function

To find ploidy and cellularity estimates, we work with a set of segments, such
such as those in t.ar.seg.  The two columns "mean" and "p" from t.ar.seg are
used for the fit. 

We first search for a ploidy/cellularity solution by assuming a one clone model 
(all tumor cells are derived from a single clone). The following function does 
the search. To reduce the amount of noise, the user might want to first focus on 
large segments:

sel<-t.ar.seg$size>10000000 
subsegments<-t.ar.seg[sel,]

ls1<-coverParamSpace( segments=subsegments, optimFct=2, lowerF=c(0), 
      upperF=c(1),Sfrom=.25, Sto=2 , maxc=12 , control=list( maxit=1000  ) )

## save(ls1, file="RdaDev/ls1.rda") 

The function tries to maximize an objective function (described below) over the 
parameter space.

When optimFct=2, the search relies on a simulated annealing 
algorithm (GenSA).  The function will search for a global maximum. 

The lowerF and upperF arguments are the 
lower and upper limits for the t parameter vector, ignoring the last entry (ie, 
lower and upper bounds for t[1:nsubclone]; here we assumed a single clone, so 
the t parameter is only t[1], the percentage of normal cells).  

The Sfrom and Sto arguments are the lower and upper bounds for S (the 
scaled read counts expected in segments that have two copies in all cells; the 
autosomal ploidy of the sequenced sample is 2/S). Thus, in the above call, the 
ploidy of the sequenced sample is allowed to go from 2/Sto=1 to 2/Sfrom=8. 
The percentage of normal cells in the sequenced sample is allowed to vary from
0% (lowerF=c(0)) to 100% (upperF=c(1)).  

The control argument is passed to the optimization function used. See ?GenSA 
for details (if optimFct=2; see ?optim if optimFct=1).

The argument maxc represents the maximum number of copies of a segment that can 
be found in any cell. Set it so that it's greater than the largest ploidy in the 
search.

The maxc argument is passed to the function prepCN, a function called from
within coverParamSpace that creates a global data.frame with the name "cn" that 
describes the allowed copy number configurations between the normal cells and 
the tumour cells.

E.g., the call of prepCN(maxc=12) creates the data.frame:

cn

   N T1
1  2  0
2  2  1
3  2  2
4  2  3
5  2  4
6  2  5
7  2  6
8  2  7
9  2  8
10 2  9
11 2 10
12 2 11
13 2 12

The first line represents a configuration where normal cells (column N) have 
two copies and tumour cells (column T1) have 0 copies in a segment.  The next 
line represents a configuration where normal cells have two copies and tumour 
cells 1 copy, etc. In the search, a segment is only allowed to have one of 
these configurations. It is from these configurations that expected peak 
locations are derived. 

The coverParamSpace function creates a global matrix called paramSpace that 
contains the value of the objective function (first column) and the value of 
c(S,t) in the other columns,  at each iteration.  It can be appended to between 
different runs using the flag addToParamSpace=T. Plotting the value of the 
objective function and the different parameters can help determine if the 
parameter space was well covered and if other local minima are worth refining:

  plot( as.data.frame(paramSpace), pch='.' )

or in details, for chosen parameters, eg,

  plot( paramSpace[,2], paramSpace[,1], pch='.', xlab="S", ylab="value" )

See FigureN1.png.

The function returns a list of lists containing among other things the optimal 
parameters and the value of the objective function.  It has length equal to 
the number of starts (controled by nrep, here 1 by default). Ie,

ls1[[1]]$value 

is the optimal value of the objective function and

ls1[[1]]$par

contains the optimal c(S, t[1],..,t[nsubcl] ):

S<-ls1[[1]]$par[1]
t<-ls1[[1]]$par[ 2:length(ls1[[1]]$par ) ]
t<-c( t, 1-sum(t) )

S
[1] 0.6331965
t
[1] 0.03776784 0.96223216

The list also includes paramSpace: ls1[[1]]$paramSpace.

The ploidy of the tumor can be calculated as:

ploidy<-( 2/S - 2*t[1])/(1-t[1])
 
ploidy
[1] 3.206366

Inspection of FigureN1.png reveals that a local maximum near S=0.3 might not 
have been well covered by the simulated annealing search.  The user can either 
use a larger number of iterations, or refine the search around that S value:

ls1.refined<-coverParamSpace( segments=subsegments, optimFct=2, lowerF=c(0), 
       upperF=c(1), Sfrom=.2, Sto=.4 , maxc=12 , control=list( maxit=1000  ),
        addToParamSpace=T )

# save( ls1.refined, file="RdaDev/ls1.refined.rda")

plot( paramSpace[,2], paramSpace[,1], pch='.', xlab="S", ylab="value" )

As a function of S, the global maximum of the objective function is clear and
no other local maxima are close to it. 

A visual assessment of the solution can be obtained with 

showTumourProfile(copyAr, maxPoints=50000 , flatten=.25 , nlev=20, 
      xlim=c(0,2) , nx=200, ny=50  )
plotModelPeaks( par=ls1[[1]]$par, cn=cn, epcol="red",epcex=1,eplwd=3 )

Red vertical lines represent the integer copy number values in tumors 
corresponding to the scaled read counts.  The red dots represent the values of 
allelic ratios for each copy number configuration found in cn.  More details and 
options can be found in 

 tutorial.4.display_solutions.txt

#####

Notice that the above solution did not capure the apparent peaks located between 
2 and 3 copies, and between 3 and 4 copies.  The user can verify that the next 
best solution in ls1.refined[[1]]$par is unsatisfactory. 

The search can be refined around the solution found above to allow for two  
subclones, in order to see if these extra peaks can be captured 
 
ls2<-coverParamSpace(  segments=subsegments, optimFct=2, lowerF=c(0.0377,0),                
       upperF=c(0.0378,.96),Sfrom=.6331, Sto=0.6332 , maxc=6 , maxsubcldiff=.5,  
       control=list( maxit=100 ) )
 
showTumourProfile(copyAr, maxPoints=50000 , flatten=.25 , nlev=20, 
      xlim=c(0,2) , nx=200, ny=50  )
plotModelPeaks( par=ls2[[1]]$par, cn=cn, epcol="red",epcex=1,eplwd=3 )

## save( ls2, file="RdaDev/li2.rda")

If >= 1, maxsubcldiff represents the upper bound for the difference in copy 
number between any two subclones.  If < 1, it represents the upper bound for 
the ratio between the minimum and maximum copy number seen across all 
subclones.  Maxc and maxsubcldiff are used in prepCN, a function called from
within coverParamSpace that creates a global data.frame with the name "cn" that 
describes the allowed copy number configurations between all subclones. The
value maxc=6 was chosen based on the one clone solution. 

Eg, prepCN(maxc=6 , nsubcl=2 , maxsubcldiff=.5 ) returns the cn data.frame:

cn

   N T1 T2
1  2  0  0
2  2  1  0
3  2  2  0
8  2  0  1
9  2  1  1
10 2  2  1
15 2  0  2
16 2  1  2
17 2  2  2
18 2  3  2
19 2  4  2
24 2  2  3
25 2  3  3
26 2  4  3
27 2  5  3
28 2  6  3
31 2  2  4
32 2  3  4
33 2  4  4
34 2  5  4
35 2  6  4
39 2  3  5
40 2  4  5
41 2  5  5
42 2  6  5
46 2  3  6
47 2  4  6
48 2  5  6
49 2  6  6

The first line represents a configuration where normal cells have two copies 
and both subclones have 0 copies in a segment.  The next line represents a 
configuration where normal cells have two copies, the first subclone has 1 copy
and the second subclone has 0 copies, etc. 

Note that when maxsubcldiff<1, a copy number 0 is treated as being 1. The above
cn data.frame (created with maxsubcldiff=0.5) describes situations where the 
copy number in a subclone is only allowed to be at most double the copy number 
of any other subclone.

The above call to coverParamSpace returned:

ls2[[1]]$par

[1] 0.6332000 0.0377000 0.5724236

S<-ls2[[1]]$par[1]
t<-ls2[[1]]$par[ 2:length(ls2[[1]]$par ) ]
t<-c( t, 1-sum(t) )

> S
[1] 0.6332
> t
[1] 0.0377000 0.5724236 0.3898764

Allowing two tumor populations or subclones, the percentage of normal cells is 
3.8%, the percentage cells in the first subclone is 57.2% and the percentage of 
cells in the second subclone is 39.0%.  

Note that the plot 

plot( paramSpace[,4], paramSpace[,1], pch=19, xlab="% Subclone 1", 
      ylab="value"  )

indicates that there is also a solution as good between 0.75-0.80. The 
corresponding line in paramSpace can be obtained using, e.g.

id<-identify( paramSpace[,4], paramSpace[,1] , n=1 )

(click one point on the above graph that is near the other local maximum), then

paramSpace[id,]

[1] 0.71313122 0.63317371 0.03770832 0.77050872 0.19178297

and the alternative solution can also be plotted: 

showTumourProfile(copyAr, maxPoints=50000 , flatten=.25 , nlev=20, 
      xlim=c(0,2) , nx=200, ny=50  )
plotModelPeaks( S=0.63317371, t=c(0.03770832, 0.77050872, 0.19178297), 
     cn=cn, epcol="red",epcex=1,eplwd=3 )



#####

Instead of first finding a one-clone solution and then refining to find a 
two-subclone solution (a stepwise approach that we recommend), the search could 
have been done by directly calling a two-subclone model:

ls3<-coverParamSpace( segments=subsegments, optimFct=2, lowerF=c(0,0), 
       upperF=c(1,1),Sfrom=.25, Sto=2 , maxc=6 , maxsubcldiff=0.5,  
       control=list( maxit=1000   ) )

however, manual curation is more difficult and challenging.

###############################################################################


In this section we illustrate how the objective function is calculated. 

For illustration purposes, let's plot the segments onto a contour plot, and add to the graph the one-clone solution above. 

par(mfrow=c(2,1))
prepCN(12) 
cntr<-showTumourProfile(copyAr, maxPoints=50000 , flatten=.25 , nlev=20, 
         xlim=c(0,2) , nx=200, ny=50  )
# only focusing and plotting on large segments
sel<-t.ar.seg$size>10000000 
subsegments<-t.ar.seg[sel,]
points(x<-subsegments$mean, y<-subsegments$p, pch=21, col="white", lwd=3, cex=2)
points( x, 1-y,  pch=21 , col="white", lwd=3 , cex=2   )
ePP<-plotModelPeaks( par=ls1[[1]]$par ,cn=cn, epcol="red",epcex=1,eplwd=3 )

We define an objective function that takes values between 0 and 1, taking the 
value 1 if 100% of the genome in subsegments is closely captured by the set of 
expected peaks (the red dots) and 0 if all the of the genome is distant from the 
model. 

The distance between each segment and its closest expected peak is calculated.
If that distance is 0, that segment is assigned a weight of 1. The larger the 
distance, the smaller the weight, down to a weight of 0 if that distance is
more than half the distance between two consecutive expected peak positions
(projected on the x-axis).

These distances (column $dist) and weights (column $we) are calculated 
when the annotateSegments function is called

subsegments<-annotateSegments(subsegments, ePP)

To illustrate, the segments points above can be plotted with size proportional 
to their weight:

# only plotting large segments
image(cntr, col=terrain.colors(20))
contour(cntr, nlev=20, add=T)
sel<-t.ar.seg$size>10000000 
points( x<-subsegments$mean, y<-subsegments$p,  pch=21 , col="white", lwd=2 ,
            cex=2*subsegments$we   )
points( x, 1-y,  pch=21 , col="white", lwd=2 ,cex=2*subsegments$we  )
plotModelPeaks( par=ls1[[1]]$par ,cn=cn, epcol="red",epcex=1,eplwd=3 )

The objective function that would need to be maximized is defined as:

sum(subsegments$size*subsegments$we)/sum(subsegments$size)

and would here take the value:

[1] 0.6672967

The weights can decrease either linearly or quadratically (the default) with the
distance. 

###############################################################################

###############################################################################

2) Peak-based objective function.

We define a "peak" to be a local maximum in a tumour profile contour plot, 
either an observed peak (as seen in the contour plot) or an expected peak 
(calculated in ways described in tutorial.1.background).

The objective function is described below. The advantage of using a peak-based
analysis as opposed to the set of segments is that the contour plot smooths out
a lot of noise. Also, the analysis is not driven by large segments: small, 
informative ones can contribute as much than large ones if they are captured in
a peak. 

A graphic window with a tumour profile must be displayed on screen:

cntr<-showTumourProfile(copyAr, maxPoints=50000 , flatten=.25 , nlev=20, 
        xlim=c(0,2) , nx=200, ny=50 )
axis(1)

The following function is used to select "peaks" that will enter the analysis. 
With getLocal=F the user is prompted to manually select peaks with left
clicks. The selection ends with a right click. 

sp <-  selectPeaks( cntr, copyAr , getLocal=F ) 

Alternatively, peaks can be automatically selected with getLocal=T. The 
function will make nrand (default 100) calls to optim() with
random starting points to find the local maxima. 

sp <-  selectPeaks( cntr, copyAr , getLocal=T , 
                    percentMax=.33, manual=F, nrand=200 , filtersymm=T   ) 

where percentMax raises the "sea level" so that smaller peaks and noise are
ignored. Here it is set to be at 33% of max( cntr$z ) (which may have been 
"flattened", depending on the call of showTumourProfle). If manual=T 
then the user is asked to choose additional points.

Note that the graph is symmetrical. Try to only select one of the two 
symmetrical points, but if not the function will do it for you. 

The function returns a data.frame containing the coordinates that we
manually selected:

sp         
          x    y
1 0.3301212 0.01
2 0.6290624 0.01
3 0.8208360 0.38
4 0.9392844 0.33
5 1.1197772 0.50
6 1.2382256 0.50
7 1.5428072 0.43

See Figure1.png.

## save( sp, file="RdaDev/sp.rda") 

We aim to find the set of parameters for which the observed peaks are best 
captured by expected peaks.  The objective function to minimize is the total
(Euclidean) distance between the observed peaks and their closest expected 
peaks.

The coverParamSpace function does the search, this time by using the 
selectedPeaks argument (instead of the segments arguments for the segment-based
search). The only other difference is that the objective function needs to 
to be minimized. 

ls4<- coverParamSpace( selectedPeaks=sp , optimFct=2, lowerF=c(0), upperF=c(1),  
       Sfrom=.25, Sto=2 , maxc=12 , control=list( maxit=1000  ) )






